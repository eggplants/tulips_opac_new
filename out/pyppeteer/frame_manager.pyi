import asyncio
from pyee import EventEmitter
from pyppeteer import helper as helper
from pyppeteer.connection import CDPSession as CDPSession
from pyppeteer.element_handle import ElementHandle as ElementHandle
from pyppeteer.errors import ElementHandleError as ElementHandleError, NetworkError as NetworkError, PageError as PageError, TimeoutError as TimeoutError
from pyppeteer.execution_context import ExecutionContext as ExecutionContext, JSHandle as JSHandle
from pyppeteer.util import merge_dict as merge_dict
from typing import Any, Awaitable, Dict, Generator, List, Optional, Union

logger: Any

class FrameManager(EventEmitter):
    Events: Any = ...
    def __init__(self, client: CDPSession, frameTree: Dict, page: Any): ...
    @property
    def mainFrame(self) -> Optional[Frame]: ...
    def frames(self) -> List[Frame]: ...
    def frame(self, frameId: str) -> Optional[Frame]: ...
    def executionContextById(self, contextId: str) -> ExecutionContext: ...
    def createJSHandle(self, context: ExecutionContext, remoteObject: Dict=...) -> JSHandle: ...

class Frame:
    def __init__(self, client: CDPSession, parentFrame: Optional[Frame], frameId: str) -> None: ...
    async def executionContext(self) -> Optional[ExecutionContext]: ...
    async def evaluateHandle(self, pageFunction: str, *args: Any) -> JSHandle: ...
    async def evaluate(self, pageFunction: str, *args: Any, force_expr: bool=...) -> Any: ...
    async def querySelector(self, selector: str) -> Optional[ElementHandle]: ...
    async def xpath(self, expression: str) -> List[ElementHandle]: ...
    async def querySelectorEval(self, selector: str, pageFunction: str, *args: Any) -> Any: ...
    async def querySelectorAllEval(self, selector: str, pageFunction: str, *args: Any) -> Optional[Dict]: ...
    async def querySelectorAll(self, selector: str) -> List[ElementHandle]: ...
    J: Any = ...
    Jx: Any = ...
    Jeval: Any = ...
    JJ: Any = ...
    JJeval: Any = ...
    async def content(self) -> str: ...
    async def setContent(self, html: str) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def url(self) -> str: ...
    @property
    def parentFrame(self) -> Optional[Frame]: ...
    @property
    def childFrames(self) -> List[Frame]: ...
    def isDetached(self) -> bool: ...
    async def injectFile(self, filePath: str) -> str: ...
    async def addScriptTag(self, options: Dict) -> ElementHandle: ...
    async def addStyleTag(self, options: Dict) -> ElementHandle: ...
    async def click(self, selector: str, options: dict=..., **kwargs: Any) -> None: ...
    async def focus(self, selector: str) -> None: ...
    async def hover(self, selector: str) -> None: ...
    async def select(self, selector: str, *values: str) -> List[str]: ...
    async def tap(self, selector: str) -> None: ...
    async def type(self, selector: str, text: str, options: dict=..., **kwargs: Any) -> None: ...
    def waitFor(self, selectorOrFunctionOrTimeout: Union[str, int, float], options: dict=..., *args: Any, **kwargs: Any) -> Union[Awaitable, WaitTask]: ...
    def waitForSelector(self, selector: str, options: dict=..., **kwargs: Any) -> WaitTask: ...
    def waitForXPath(self, xpath: str, options: dict=..., **kwargs: Any) -> WaitTask: ...
    def waitForFunction(self, pageFunction: str, options: dict=..., *args: Any, **kwargs: Any) -> WaitTask: ...
    async def title(self) -> str: ...

class WaitTask:
    promise: Any = ...
    def __init__(self, frame: Frame, predicateBody: str, title: str, polling: Union[str, int], timeout: float, loop: asyncio.AbstractEventLoop, *args: Any) -> None: ...
    def __await__(self) -> Generator: ...
    def terminate(self, error: Exception) -> None: ...
    async def rerun(self) -> None: ...

waitForPredicatePageFunction: str
