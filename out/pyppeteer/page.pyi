from pyee import EventEmitter
from pyppeteer import helper as helper
from pyppeteer.browser import Browser as Browser, Target as Target
from pyppeteer.connection import CDPSession as CDPSession
from pyppeteer.coverage import Coverage as Coverage
from pyppeteer.dialog import Dialog as Dialog
from pyppeteer.element_handle import ElementHandle as ElementHandle
from pyppeteer.emulation_manager import EmulationManager as EmulationManager
from pyppeteer.errors import PageError as PageError
from pyppeteer.execution_context import JSHandle as JSHandle
from pyppeteer.frame_manager import Frame as Frame, FrameManager as FrameManager
from pyppeteer.helper import debugError as debugError
from pyppeteer.input import Keyboard as Keyboard, Mouse as Mouse, Touchscreen as Touchscreen
from pyppeteer.navigator_watcher import NavigatorWatcher as NavigatorWatcher
from pyppeteer.network_manager import NetworkManager as NetworkManager, Request as Request, Response as Response
from pyppeteer.tracing import Tracing as Tracing
from pyppeteer.util import merge_dict as merge_dict
from pyppeteer.worker import Worker as Worker
from typing import Any, Awaitable, Callable, Dict, List, Optional, Union

logger: Any

class Page(EventEmitter):
    Events: Any = ...
    PaperFormats: Dict[str, Dict[str, float]] = ...
    @staticmethod
    async def create(client: CDPSession, target: Target, ignoreHTTPSErrors: bool, defaultViewport: Optional[Dict], screenshotTaskQueue: list=...) -> Page: ...
    def __init__(self, client: CDPSession, target: Target, frameTree: Dict, ignoreHTTPSErrors: bool, screenshotTaskQueue: list=...): ...
    @property
    def target(self) -> Target: ...
    @property
    def browser(self) -> Browser: ...
    @property
    def mainFrame(self) -> Optional[Frame]: ...
    @property
    def keyboard(self) -> Keyboard: ...
    @property
    def touchscreen(self) -> Touchscreen: ...
    @property
    def coverage(self) -> Coverage: ...
    async def tap(self, selector: str) -> None: ...
    @property
    def tracing(self) -> Tracing: ...
    @property
    def frames(self) -> List[Frame]: ...
    @property
    def workers(self) -> List[Worker]: ...
    async def setRequestInterception(self, value: bool) -> None: ...
    async def setOfflineMode(self, enabled: bool) -> None: ...
    def setDefaultNavigationTimeout(self, timeout: int) -> None: ...
    async def querySelector(self, selector: str) -> Optional[ElementHandle]: ...
    async def evaluateHandle(self, pageFunction: str, *args: Any) -> JSHandle: ...
    async def queryObjects(self, prototypeHandle: JSHandle) -> JSHandle: ...
    async def querySelectorEval(self, selector: str, pageFunction: str, *args: Any) -> Any: ...
    async def querySelectorAllEval(self, selector: str, pageFunction: str, *args: Any) -> Any: ...
    async def querySelectorAll(self, selector: str) -> List[ElementHandle]: ...
    async def xpath(self, expression: str) -> List[ElementHandle]: ...
    J: Any = ...
    Jeval: Any = ...
    JJ: Any = ...
    JJeval: Any = ...
    Jx: Any = ...
    async def cookies(self, *urls: str) -> List[Dict[str, Union[str, int, bool]]]: ...
    async def deleteCookie(self, *cookies: dict) -> None: ...
    async def setCookie(self, *cookies: dict) -> None: ...
    async def addScriptTag(self, options: Dict=..., **kwargs: str) -> ElementHandle: ...
    async def addStyleTag(self, options: Dict=..., **kwargs: str) -> ElementHandle: ...
    async def injectFile(self, filePath: str) -> str: ...
    async def exposeFunction(self, name: str, pyppeteerFunction: Callable[..., Any]) -> None: ...
    async def authenticate(self, credentials: Dict[str, str]) -> Any: ...
    async def setExtraHTTPHeaders(self, headers: Dict[str, str]) -> None: ...
    async def setUserAgent(self, userAgent: str) -> None: ...
    async def metrics(self) -> Dict[str, Any]: ...
    @property
    def url(self) -> str: ...
    async def content(self) -> str: ...
    async def setContent(self, html: str) -> None: ...
    async def goto(self, url: str, options: dict=..., **kwargs: Any) -> Optional[Response]: ...
    async def reload(self, options: dict=..., **kwargs: Any) -> Optional[Response]: ...
    async def waitForNavigation(self, options: dict=..., **kwargs: Any) -> Optional[Response]: ...
    async def waitForRequest(self, urlOrPredicate: Union[str, Callable[[Request], bool]], options: Dict=..., **kwargs: Any) -> Request: ...
    async def waitForResponse(self, urlOrPredicate: Union[str, Callable[[Response], bool]], options: Dict=..., **kwargs: Any) -> Response: ...
    async def goBack(self, options: dict=..., **kwargs: Any) -> Optional[Response]: ...
    async def goForward(self, options: dict=..., **kwargs: Any) -> Optional[Response]: ...
    async def bringToFront(self) -> None: ...
    async def emulate(self, options: dict=..., **kwargs: Any) -> None: ...
    async def setJavaScriptEnabled(self, enabled: bool) -> None: ...
    async def setBypassCSP(self, enabled: bool) -> None: ...
    async def emulateMedia(self, mediaType: str=...) -> None: ...
    async def setViewport(self, viewport: dict) -> None: ...
    @property
    def viewport(self) -> Optional[Dict]: ...
    async def evaluate(self, pageFunction: str, *args: Any, force_expr: bool=...) -> Any: ...
    async def evaluateOnNewDocument(self, pageFunction: str, *args: str) -> None: ...
    async def setCacheEnabled(self, enabled: bool=...) -> None: ...
    async def screenshot(self, options: dict=..., **kwargs: Any) -> Union[bytes, str]: ...
    async def pdf(self, options: dict=..., **kwargs: Any) -> bytes: ...
    async def plainText(self) -> str: ...
    async def title(self) -> str: ...
    async def close(self, options: Dict=..., **kwargs: Any) -> None: ...
    def isClosed(self) -> bool: ...
    @property
    def mouse(self) -> Mouse: ...
    async def click(self, selector: str, options: dict=..., **kwargs: Any) -> None: ...
    async def hover(self, selector: str) -> None: ...
    async def focus(self, selector: str) -> None: ...
    async def select(self, selector: str, *values: str) -> List[str]: ...
    async def type(self, selector: str, text: str, options: dict=..., **kwargs: Any) -> None: ...
    def waitFor(self, selectorOrFunctionOrTimeout: Union[str, int, float], options: dict=..., *args: Any, **kwargs: Any) -> Awaitable: ...
    def waitForSelector(self, selector: str, options: dict=..., **kwargs: Any) -> Awaitable: ...
    def waitForXPath(self, xpath: str, options: dict=..., **kwargs: Any) -> Awaitable: ...
    def waitForFunction(self, pageFunction: str, options: dict=..., *args: str, **kwargs: Any) -> Awaitable: ...

supportedMetrics: Any
unitToPixels: Any

def convertPrintParameterToInches(parameter: Union[None, int, float, str]) -> Optional[float]: ...

class ConsoleMessage:
    def __init__(self, type: str, text: str, args: List[JSHandle]=...) -> None: ...
    @property
    def type(self) -> str: ...
    @property
    def text(self) -> str: ...
    @property
    def args(self) -> List[JSHandle]: ...

async def craete(*args: Any, **kwargs: Any) -> Page: ...
