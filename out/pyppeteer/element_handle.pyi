from pyppeteer.connection import CDPSession as CDPSession
from pyppeteer.errors import ElementHandleError as ElementHandleError, NetworkError as NetworkError
from pyppeteer.execution_context import ExecutionContext as ExecutionContext, JSHandle as JSHandle
from pyppeteer.frame_manager import Frame as Frame, FrameManager as FrameManager
from pyppeteer.helper import debugError as debugError
from pyppeteer.util import merge_dict as merge_dict
from typing import Any, Dict, List, Optional

logger: Any

class ElementHandle(JSHandle):
    def __init__(self, context: ExecutionContext, client: CDPSession, remoteObject: dict, page: Any, frameManager: FrameManager) -> None: ...
    def asElement(self) -> ElementHandle: ...
    async def contentFrame(self) -> Optional[Frame]: ...
    async def hover(self) -> None: ...
    async def click(self, options: dict=..., **kwargs: Any) -> None: ...
    async def uploadFile(self, *filePaths: str) -> dict: ...
    async def tap(self) -> None: ...
    async def focus(self) -> None: ...
    async def type(self, text: str, options: Dict=..., **kwargs: Any) -> None: ...
    async def press(self, key: str, options: Dict=..., **kwargs: Any) -> None: ...
    async def boundingBox(self) -> Optional[Dict[str, float]]: ...
    async def boxModel(self) -> Optional[Dict]: ...
    async def screenshot(self, options: Dict=..., **kwargs: Any) -> bytes: ...
    async def querySelector(self, selector: str) -> Optional[ElementHandle]: ...
    async def querySelectorAll(self, selector: str) -> List[ElementHandle]: ...
    async def querySelectorEval(self, selector: str, pageFunction: str, *args: Any) -> Any: ...
    async def querySelectorAllEval(self, selector: str, pageFunction: str, *args: Any) -> Any: ...
    J: Any = ...
    JJ: Any = ...
    Jeval: Any = ...
    JJeval: Any = ...
    async def xpath(self, expression: str) -> List[ElementHandle]: ...
    Jx: Any = ...
    async def isIntersectingViewport(self) -> bool: ...
